## Задание 3

1. Создайте таблицу с большим количеством данных:
    ```sql
    CREATE TABLE test_cluster AS 
    SELECT 
        generate_series(1,1000000) as id,
        CASE WHEN random() < 0.5 THEN 'A' ELSE 'B' END as category,
        md5(random()::text) as data;
    ```

2. Создайте индекс:
    ```sql
    CREATE INDEX test_cluster_cat_idx ON test_cluster(category);
    ```

3. Измерьте производительность до кластеризации:
    ```sql
    EXPLAIN ANALYZE
    SELECT * FROM test_cluster WHERE category = 'A';
    ```
    
    *План выполнения:*
    ```
    Bitmap Heap Scan on test_cluster  (cost=59.17..7696.73 rows=5000 width=68) (actual time=41.876..175.125 rows=500387 loops=1)
      Recheck Cond: (category = 'A'::text)
      Heap Blocks: exact=8334
      ->  Bitmap Index Scan on test_cluster_cat_idx  (cost=0.00..57.92 rows=5000 width=0) (actual time=38.342..38.343 rows=500387 loops=1)
            Index Cond: (category = 'A'::text)
    Planning Time: 0.918 ms
    Execution Time: 194.481 ms
    ```
    
    *Объясните результат:*
    Запрос использует Bitmap Heap Scan с Bitmap Index Scan по индексу test_cluster_cat_idx. Найдено 500387 строк (примерно половина от 1 миллиона, что соответствует распределению данных). Видно, что прочитано 8334 точных блоков (Heap Blocks: exact=8334), что означает, что данные с category='A' разбросаны по всей таблице и занимают много различных страниц. Время выполнения составляет 194.481 ms.

4. Выполните кластеризацию:
    ```sql
    CLUSTER test_cluster USING test_cluster_cat_idx;
    ```
    
    *Результат:*
    ```
    CLUSTER
    ```
    
    Кластеризация успешно выполнена. Таблица test_cluster теперь физически упорядочена по индексу test_cluster_cat_idx, что означает, что все строки с одинаковым значением category расположены рядом друг с другом на диске.

5. Измерьте производительность после кластеризации:
    ```sql
    EXPLAIN ANALYZE
    SELECT * FROM test_cluster WHERE category = 'A';
    ```
    
    *План выполнения:*
    ```
    Bitmap Heap Scan on test_cluster  (cost=59.17..7668.56 rows=5000 width=68) (actual time=7.122..44.552 rows=500387 loops=1)
      Recheck Cond: (category = 'A'::text)
      Heap Blocks: exact=4170
      ->  Bitmap Index Scan on test_cluster_cat_idx  (cost=0.00..57.92 rows=5000 width=0) (actual time=6.699..6.700 rows=500387 loops=1)
            Index Cond: (category = 'A'::text)
    Planning Time: 0.348 ms
    Execution Time: 56.136 ms
    ```
    
    *Объясните результат:*
    После кластеризации запрос также использует Bitmap Heap Scan, но количество прочитанных блоков значительно уменьшилось: с 8334 до 4170 (Heap Blocks: exact=4170). Это означает, что данные с category='A' теперь сгруппированы и занимают примерно в 2 раза меньше страниц. Время выполнения улучшилось с 194.481 ms до 56.136 ms, что составляет ускорение примерно в 3.5 раза. Это демонстрирует эффективность кластеризации для запросов, которые выбирают большое количество строк по индексированному ключу.

6. Сравните производительность до и после кластеризации:
    
    *Сравнение:*
    Кластеризация показала значительное улучшение производительности:
    
    **До кластеризации:**
    - Время выполнения: 194.481 ms
    - Прочитано блоков: 8334 (exact)
    - Данные разбросаны по всей таблице
    
    **После кластеризации:**
    - Время выполнения: 56.136 ms
    - Прочитано блоков: 4170 (exact)
    - Данные сгруппированы по category
    
    **Улучшения:**
    - Ускорение выполнения: ~3.5 раза (194.481 ms → 56.136 ms)
    - Сокращение количества блоков: ~2 раза (8334 → 4170)
    - Улучшение использования кэша: меньше случайных чтений с диска
    
    Кластеризация эффективна для запросов, которые выбирают большое количество строк по индексированному ключу, так как данные физически упорядочиваются, что уменьшает количество страниц, которые нужно прочитать с диска, и улучшает использование кэша операционной системы и PostgreSQL.